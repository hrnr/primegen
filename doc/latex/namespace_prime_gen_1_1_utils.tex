\hypertarget{namespace_prime_gen_1_1_utils}{\section{Prime\+Gen\+:\+:Utils Namespace Reference}
\label{namespace_prime_gen_1_1_utils}\index{Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}}
}


Various arithmetic functions used in library algorithms.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename U\+Int\+Type $>$ }\\std\+::pair$<$ U\+Int\+Type, U\+Int\+Type $>$ \hyperlink{namespace_prime_gen_1_1_utils_a35a61b9560765cd3e254be8e8f8ad8c1}{fac\+\_\+2\+\_\+powers} (const U\+Int\+Type \&n)
\begin{DoxyCompactList}\small\item\em Factorize powers of 2 from n. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename U\+Int\+Type $>$ }\\U\+Int\+Type \hyperlink{namespace_prime_gen_1_1_utils_a640cffdfe9303cbe0eb0205165c3161e}{pow\+\_\+mod} (U\+Int\+Type base, U\+Int\+Type exp, const U\+Int\+Type \&mod)
\begin{DoxyCompactList}\small\item\em Exponentiation over a modulo. Exponentiation will be done by repeated squaring. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename U\+Int\+Type , size\+\_\+t w$>$ }\\double \hyperlink{namespace_prime_gen_1_1_utils_ab651d715c25dfed57573d950ee5451c7}{log} (const U\+Int\+Type \&n)
\begin{DoxyCompactList}\small\item\em Logarithm function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename U\+Int\+Type , typename Engine\+Type , size\+\_\+t w$>$ }\\U\+Int\+Type \hyperlink{namespace_prime_gen_1_1_utils_a279cd6b89aca43a9597f58aa4a7b5807}{independent\+\_\+bits\+\_\+generator} (Engine\+Type \&\+\_\+32b\+\_\+generator)
\begin{DoxyCompactList}\small\item\em Generates random number using provided engine. Randomness of generated number depends on randomness of provided engine. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Various arithmetic functions used in library algorithms. 

\subsection{Function Documentation}
\hypertarget{namespace_prime_gen_1_1_utils_a35a61b9560765cd3e254be8e8f8ad8c1}{\index{Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}!fac\+\_\+2\+\_\+powers@{fac\+\_\+2\+\_\+powers}}
\index{fac\+\_\+2\+\_\+powers@{fac\+\_\+2\+\_\+powers}!Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}}
\subsubsection[{fac\+\_\+2\+\_\+powers}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename U\+Int\+Type $>$ std\+::pair$<$ U\+Int\+Type, U\+Int\+Type $>$ Prime\+Gen\+::\+Utils\+::fac\+\_\+2\+\_\+powers (
\begin{DoxyParamCaption}
\item[{const U\+Int\+Type \&}]{n}
\end{DoxyParamCaption}
)}}\label{namespace_prime_gen_1_1_utils_a35a61b9560765cd3e254be8e8f8ad8c1}


Factorize powers of 2 from n. 


\begin{DoxyTemplParams}{Template Parameters}
{\em U\+Int\+Type} & Unsigned integer type.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em n} & number to be factorized\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::pair (s, d) where s, d holds $ n = 2^{s} \times d *$ 
\end{DoxyReturn}
\hypertarget{namespace_prime_gen_1_1_utils_a279cd6b89aca43a9597f58aa4a7b5807}{\index{Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}!independent\+\_\+bits\+\_\+generator@{independent\+\_\+bits\+\_\+generator}}
\index{independent\+\_\+bits\+\_\+generator@{independent\+\_\+bits\+\_\+generator}!Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}}
\subsubsection[{independent\+\_\+bits\+\_\+generator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename U\+Int\+Type , typename Engine\+Type , size\+\_\+t w$>$ U\+Int\+Type Prime\+Gen\+::\+Utils\+::independent\+\_\+bits\+\_\+generator (
\begin{DoxyParamCaption}
\item[{Engine\+Type \&}]{\+\_\+32b\+\_\+generator}
\end{DoxyParamCaption}
)}}\label{namespace_prime_gen_1_1_utils_a279cd6b89aca43a9597f58aa4a7b5807}


Generates random number using provided engine. Randomness of generated number depends on randomness of provided engine. 


\begin{DoxyTemplParams}{Template Parameters}
{\em U\+Int\+Type} & Unsigned integer type. Must be able to hold {\ttfamily w} long numbers \\
\hline
{\em Engine\+Type} & Function support all standard engine types defined in {\ttfamily $<$random$>$}, including {\ttfamily std\+::random\+\_\+device}. (Hence all classes generating 32b numbers with {\ttfamily }() operator should work). Internal state of engine will be modified. Engine must be initialized and provide {\ttfamily }() operator generating 32b numbers. \\
\hline
{\em w} & size of number to generate in bits\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em \+\_\+32b\+\_\+generator} & Initialized number generator\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
random number of width {\ttfamily w} 
\end{DoxyReturn}
\hypertarget{namespace_prime_gen_1_1_utils_ab651d715c25dfed57573d950ee5451c7}{\index{Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}!log@{log}}
\index{log@{log}!Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}}
\subsubsection[{log}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename U\+Int\+Type , size\+\_\+t w$>$ double Prime\+Gen\+::\+Utils\+::log (
\begin{DoxyParamCaption}
\item[{const U\+Int\+Type \&}]{n}
\end{DoxyParamCaption}
)}}\label{namespace_prime_gen_1_1_utils_ab651d715c25dfed57573d950ee5451c7}


Logarithm function. 

Computes logarithm with maximum precision avaible for standart types. {\bfseries U\+Int\+Type} must be able to print itself to stream (ie. stream operator $<$$<$ must bbe defined) \begin{DoxyVerb}        @tparam UIntType Unsigned integer type.
        @tparam w size of \b n in bits

        @param n number to compute logarithm for
        @return natural logarithm of n\end{DoxyVerb}
 \hypertarget{namespace_prime_gen_1_1_utils_a640cffdfe9303cbe0eb0205165c3161e}{\index{Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}!pow\+\_\+mod@{pow\+\_\+mod}}
\index{pow\+\_\+mod@{pow\+\_\+mod}!Prime\+Gen\+::\+Utils@{Prime\+Gen\+::\+Utils}}
\subsubsection[{pow\+\_\+mod}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename U\+Int\+Type $>$ U\+Int\+Type Prime\+Gen\+::\+Utils\+::pow\+\_\+mod (
\begin{DoxyParamCaption}
\item[{U\+Int\+Type}]{base, }
\item[{U\+Int\+Type}]{exp, }
\item[{const U\+Int\+Type \&}]{mod}
\end{DoxyParamCaption}
)}}\label{namespace_prime_gen_1_1_utils_a640cffdfe9303cbe0eb0205165c3161e}


Exponentiation over a modulo. Exponentiation will be done by repeated squaring. 


\begin{DoxyTemplParams}{Template Parameters}
{\em U\+Int\+Type} & Unsigned integer type. Must be able to hold 2 times size of {\ttfamily base} and {\ttfamily mod}. (Even if {\ttfamily base} would fit in 32b type {\ttfamily U\+Int\+Type} must be able to hold 64b number.) \begin{DoxyVerb}        @param base
        @param exp exponent
        @param mod modulo

        @return  \form#5\end{DoxyVerb}
 \\
\hline
\end{DoxyTemplParams}
